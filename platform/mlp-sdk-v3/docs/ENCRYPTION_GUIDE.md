# Encryption Guide for mlp_sdk

This guide explains how to use encryption features in mlp_sdk to protect sensitive configuration values.

## Table of Contents

- [Overview](#overview)
- [Encryption Algorithm](#encryption-algorithm)
- [Key Management](#key-management)
- [Encrypting Configuration Files](#encrypting-configuration-files)
- [Decrypting Configuration Files](#decrypting-configuration-files)
- [Best Practices](#best-practices)
- [Security Considerations](#security-considerations)
- [Troubleshooting](#troubleshooting)

## Overview

mlp_sdk provides built-in encryption support for sensitive configuration values such as:

- IAM role ARNs
- KMS key IDs
- S3 bucket names
- Security group IDs
- Any other sensitive configuration data

The encryption system uses **AES-256-GCM** (Advanced Encryption Standard with Galois/Counter Mode), which provides:

- **Confidentiality**: Data is encrypted and unreadable without the key
- **Integrity**: Tampering with encrypted data is detected
- **Authentication**: Ensures data comes from a trusted source

## Encryption Algorithm

### AES-256-GCM

mlp_sdk uses AES-256-GCM for encryption:

- **Key size**: 256 bits (32 bytes)
- **Nonce size**: 96 bits (12 bytes) - randomly generated for each encryption
- **Authentication tag**: 128 bits (16 bytes) - automatically included
- **Mode**: Galois/Counter Mode (GCM) - provides both encryption and authentication

### Encrypted Value Format

Encrypted values are stored as base64-encoded strings with the following structure:

```
base64(nonce || ciphertext || auth_tag)
```

Where:
- `nonce`: 12-byte random value (unique per encryption)
- `ciphertext`: Encrypted data
- `auth_tag`: 16-byte authentication tag (automatically included by GCM)

## Key Management

### Generating Encryption Keys

#### Generate a New Key

```python
from mlp_sdk.config import ConfigurationManager

# Generate a new 256-bit encryption key
key = ConfigurationManager.generate_key()
print(f"Encryption key (save securely): {key}")
```

The generated key is a base64-encoded 32-byte random value. **Save this key securely** - you'll need it to decrypt your configuration.

#### Save Key to Environment Variable

```bash
# Linux/macOS
export MLP_SDK_ENCRYPTION_KEY="your-base64-encoded-key"

# Windows PowerShell
$env:MLP_SDK_ENCRYPTION_KEY="your-base64-encoded-key"

# Windows Command Prompt
set MLP_SDK_ENCRYPTION_KEY=your-base64-encoded-key
```

#### Save Key to File

```bash
# Save key to a file
echo "your-base64-encoded-key" > /secure/path/encryption.key

# Set restrictive permissions (Linux/macOS)
chmod 600 /secure/path/encryption.key
```

### Loading Encryption Keys

#### From Environment Variable

```python
from mlp_sdk.config import ConfigurationManager

# Load key from environment variable (default: MLP_SDK_ENCRYPTION_KEY)
key = ConfigurationManager.load_key_from_env()

# Or specify custom environment variable name
key = ConfigurationManager.load_key_from_env(env_var="MY_CUSTOM_KEY_VAR")

# Use with configuration manager
config_manager = ConfigurationManager(
    config_path="encrypted-config.yaml",
    encryption_key=key
)
```

#### From File

```python
from mlp_sdk.config import ConfigurationManager

# Load key from file
key = ConfigurationManager.load_key_from_file("/secure/path/encryption.key")

# Use with configuration manager
config_manager = ConfigurationManager(
    config_path="encrypted-config.yaml",
    encryption_key=key
)
```

#### From AWS KMS

```python
from mlp_sdk.config import ConfigurationManager

# Load key from AWS KMS
key = ConfigurationManager.load_key_from_kms(
    key_id="arn:aws:kms:REGION:ACCOUNT-ID:key/KEY-ID",
    region="us-west-2"
)

# Use with configuration manager
config_manager = ConfigurationManager(
    config_path="encrypted-config.yaml",
    encryption_key=key
)
```

**Note**: When using KMS, the key is generated by KMS and returned as plaintext. This provides centralized key management and audit trails through AWS CloudTrail.

#### Provide Key Directly

```python
from mlp_sdk.config import ConfigurationManager

# Provide key as base64 string
key_string = "your-base64-encoded-key"
config_manager = ConfigurationManager(
    config_path="encrypted-config.yaml",
    encryption_key=key_string
)

# Or as raw bytes
key_bytes = b'\x00\x01\x02...'  # 32 bytes
config_manager = ConfigurationManager(
    config_path="encrypted-config.yaml",
    encryption_key=key_bytes
)
```

## Encrypting Configuration Files

### Encrypt Specific Fields

```python
from mlp_sdk.config import ConfigurationManager

# Generate or load encryption key
key = ConfigurationManager.generate_key()

# Create configuration manager
config_manager = ConfigurationManager(encryption_key=key)

# Encrypt specific fields in configuration file
config_manager.encrypt_config_file(
    input_path="config.yaml",
    output_path="config-encrypted.yaml",
    fields_to_encrypt=[
        "defaults.iam.execution_role",
        "defaults.kms.key_id",
        "defaults.s3.default_bucket"
    ]
)

print("Configuration encrypted successfully")
print(f"Save this key securely: {key}")
```

### Example: Before Encryption

```yaml
# config.yaml
defaults:
  s3:
    default_bucket: "my-sagemaker-bucket"
    input_prefix: "input/"
    
  iam:
    execution_role: "arn:aws:iam::123456789012:role/SageMakerExecutionRole"
    
  kms:
    key_id: "arn:aws:kms:REGION:ACCOUNT-ID:key/KEY-ID"
```

### Example: After Encryption

```yaml
# config-encrypted.yaml
defaults:
  s3:
    default_bucket: "gAAAAABl1234abcd...encrypted-value...xyz="
    input_prefix: "input/"
    
  iam:
    execution_role: "gAAAAABl5678efgh...encrypted-value...uvw="
    
  kms:
    key_id: "gAAAAABl9012ijkl...encrypted-value...rst="
```

### Encrypt All Sensitive Fields

```python
from mlp_sdk.config import ConfigurationManager

# Generate encryption key
key = ConfigurationManager.generate_key()
config_manager = ConfigurationManager(encryption_key=key)

# Encrypt all sensitive fields
sensitive_fields = [
    "defaults.iam.execution_role",
    "defaults.kms.key_id",
    "defaults.s3.default_bucket",
    "defaults.networking.vpc_id",
    "defaults.networking.security_group_ids",
    "defaults.networking.subnets"
]

config_manager.encrypt_config_file(
    input_path="config.yaml",
    output_path="config-encrypted.yaml",
    fields_to_encrypt=sensitive_fields
)

# Save key to environment variable or secure location
print(f"Encryption key: {key}")
```

## Decrypting Configuration Files

### Decrypt Specific Fields

```python
from mlp_sdk.config import ConfigurationManager

# Load encryption key
key = ConfigurationManager.load_key_from_env()

# Create configuration manager
config_manager = ConfigurationManager(encryption_key=key)

# Decrypt specific fields
config_manager.decrypt_config_file(
    input_path="config-encrypted.yaml",
    output_path="config-decrypted.yaml",
    fields_to_decrypt=[
        "defaults.iam.execution_role",
        "defaults.kms.key_id",
        "defaults.s3.default_bucket"
    ]
)

print("Configuration decrypted successfully")
```

### Using Encrypted Configuration with MLP_Session

```python
from mlp_sdk import MLP_Session
from mlp_sdk.config import ConfigurationManager

# Load encryption key
key = ConfigurationManager.load_key_from_env()

# Initialize session with encrypted configuration
# Note: Currently, you need to decrypt the config first or use ConfigurationManager directly
config_manager = ConfigurationManager(
    config_path="config-encrypted.yaml",
    encryption_key=key
)

# Then use the configuration manager with your session
# (Implementation detail: you may need to decrypt to a temp file first)
```

## Best Practices

### Key Management

1. **Never commit encryption keys to version control**
   - Add key files to `.gitignore`
   - Use environment variables or secure key management systems

2. **Use different keys for different environments**
   - Development, staging, and production should have separate keys
   - Rotate keys periodically

3. **Store keys securely**
   - Use AWS Secrets Manager or AWS Systems Manager Parameter Store
   - Use AWS KMS for centralized key management
   - Use hardware security modules (HSMs) for high-security requirements

4. **Limit key access**
   - Only authorized personnel should have access to encryption keys
   - Use IAM policies to control access to KMS keys
   - Audit key usage through CloudTrail

### Configuration File Management

1. **Encrypt sensitive fields only**
   - Don't encrypt the entire configuration file
   - Only encrypt fields that contain sensitive data
   - This makes debugging easier and reduces overhead

2. **Version control encrypted configurations**
   - Encrypted configuration files can be safely committed to version control
   - Ensure keys are stored separately and securely

3. **Document encrypted fields**
   - Maintain a list of which fields are encrypted
   - Document the encryption key source (environment variable, KMS, etc.)

### Operational Practices

1. **Test encryption/decryption**
   - Verify encryption and decryption work correctly before deploying
   - Test key rotation procedures

2. **Have a key recovery plan**
   - Backup encryption keys securely
   - Document key recovery procedures
   - Test recovery procedures regularly

3. **Monitor and audit**
   - Log encryption/decryption operations
   - Monitor for failed decryption attempts
   - Use CloudTrail to audit KMS key usage

## Security Considerations

### Encryption Strength

- **AES-256-GCM** is a NIST-approved encryption algorithm
- Provides 256-bit security level (computationally infeasible to break)
- GCM mode provides authenticated encryption (prevents tampering)

### Key Security

- **32-byte (256-bit) keys** provide strong security
- Keys should be randomly generated using cryptographically secure random number generators
- Never derive keys from passwords without proper key derivation functions (PBKDF2, Argon2, etc.)

### Nonce Uniqueness

- Each encryption operation uses a unique random nonce
- Nonce reuse with the same key can compromise security
- mlp_sdk automatically generates unique nonces for each encryption

### Authentication

- GCM mode provides authentication tags that detect tampering
- Any modification to encrypted data will be detected during decryption
- Authentication tags are automatically verified during decryption

### Key Rotation

To rotate encryption keys:

1. Generate a new encryption key
2. Decrypt configuration with old key
3. Encrypt configuration with new key
4. Update key storage (environment variables, files, KMS)
5. Securely delete old key

```python
from mlp_sdk.config import ConfigurationManager

# Load old key
old_key = ConfigurationManager.load_key_from_env()

# Generate new key
new_key = ConfigurationManager.generate_key()

# Decrypt with old key
old_config_manager = ConfigurationManager(encryption_key=old_key)
old_config_manager.decrypt_config_file(
    input_path="config-encrypted.yaml",
    output_path="config-temp.yaml",
    fields_to_decrypt=["defaults.iam.execution_role", ...]
)

# Encrypt with new key
new_config_manager = ConfigurationManager(encryption_key=new_key)
new_config_manager.encrypt_config_file(
    input_path="config-temp.yaml",
    output_path="config-encrypted-new.yaml",
    fields_to_encrypt=["defaults.iam.execution_role", ...]
)

# Update key storage
print(f"New encryption key: {new_key}")

# Clean up temporary file
import os
os.remove("config-temp.yaml")
```

## Troubleshooting

### Error: "Encryption key must be 32 bytes for AES-256"

**Cause**: The provided encryption key is not exactly 32 bytes.

**Solution**: Ensure you're using a properly generated key:

```python
from mlp_sdk.config import ConfigurationManager

# Generate a valid key
key = ConfigurationManager.generate_key()

# Or ensure your key is base64-encoded and decodes to 32 bytes
import base64
key_bytes = base64.b64decode(your_key_string)
assert len(key_bytes) == 32
```

### Error: "Failed to decrypt value"

**Cause**: The encryption key doesn't match the key used for encryption, or the encrypted data is corrupted.

**Solutions**:

1. Verify you're using the correct encryption key
2. Check that the encrypted value hasn't been modified
3. Ensure the encrypted value is properly base64-encoded

```python
from mlp_sdk.config import ConfigurationManager

# Verify key is correct
key = ConfigurationManager.load_key_from_env()
config_manager = ConfigurationManager(encryption_key=key)

# Test encryption/decryption
test_value = "test"
encrypted = config_manager.encrypt_value(test_value)
decrypted = config_manager.decrypt_value(encrypted)
assert test_value == decrypted
```

### Error: "No encryption key available"

**Cause**: No encryption key was provided to the ConfigurationManager.

**Solution**: Provide an encryption key:

```python
from mlp_sdk.config import ConfigurationManager

# Load key from environment
key = ConfigurationManager.load_key_from_env()

# Or generate a new key
key = ConfigurationManager.generate_key()

# Provide key to configuration manager
config_manager = ConfigurationManager(encryption_key=key)
```

### Error: "Field path not found"

**Cause**: The specified field path doesn't exist in the configuration file.

**Solution**: Verify the field path using dot notation:

```python
# Correct field paths use dot notation
fields_to_encrypt = [
    "defaults.iam.execution_role",  # Correct
    "defaults.s3.default_bucket",   # Correct
]

# Not:
# "iam.execution_role"  # Missing 'defaults' prefix
# "defaults/iam/execution_role"  # Wrong separator
```

### Performance Considerations

Encryption and decryption operations are fast but not free:

- **Encryption**: ~0.1-1ms per value
- **Decryption**: ~0.1-1ms per value
- **File operations**: Dominated by I/O time

For best performance:

1. Encrypt only sensitive fields (not the entire configuration)
2. Cache decrypted values when possible
3. Use KMS sparingly (network latency)

### AWS KMS Considerations

When using AWS KMS:

- **Network latency**: KMS calls require network round-trips
- **Rate limits**: KMS has API rate limits (varies by region)
- **Costs**: KMS charges per API call
- **Permissions**: Ensure IAM permissions for `kms:GenerateDataKey`

```python
# KMS permissions required
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": [
                "kms:GenerateDataKey",
                "kms:Decrypt"
            ],
            "Resource": "arn:aws:kms:region:account:key/key-id"
        }
    ]
}
```

## Additional Resources

- [NIST AES Specification](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf)
- [GCM Mode Specification](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf)
- [AWS KMS Documentation](https://docs.aws.amazon.com/kms/)
- [Python Cryptography Library](https://cryptography.io/)
